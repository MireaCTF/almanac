---
title: "Crypto basics"
description: ""
date: 2024-04-08
summary: "Немного базы по криптографии, системе обмена файлами"

series: ["Crypto basics"]
series_order: 1

tags: ["Crypto"]
showAuthor: true
authors:
  - "Zer0bp"
---
<script
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript">
</script>
Сегодня на повестке дня: ~~Умеет ли Габен считать до трех?~~, разбор криптографической базы, а именно парсинг .pem файлов, а также решение простой задачи на RSA с TamuCTF.


Разберемся зачем нужен .pem файл.PEM - это де-факто формат файла для хранения и отправки криптографических ключей, сертификатов и других данных, основанный на наборе стандартов IETF 1993 года, определяющих "почту с улучшенной конфиденциальностью" ([Ссылка](https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail) ).


[Тасоки и решения](https://disk.yandex.ru/d/ctH0KnQoO71rTg)
=

Truncated 1:
=
Условие задачи
-
1. Дан зашифрованный флаг
2. Дан открытый ключ шифрования
3. Дана часть приватного ключа шифрования
 
Решение
-
Oh no! У нас не полный приватный ключ, чтобы сдать тасоку налегке. Поищем, что должно лежать в PEM файле. Сам по себе pem файл - таблица ASN.1, которая зашифрована с помощью протокола der, а после еще вдобавок - base64.



Как работает DER?
-
DER, по сути дела, берет все чиселки переводит их в хексы(hexadecimal), приписывая поля, также в хексах ([Читать подробнее](https://en.wikipedia.org/wiki/ASN.1#Encoding_Control_Notation)). Нас интересуют поля 02 - как integer, за которыми следуют 81,82. Почему 81, 82? Так обозначаются крупные чиселки. Если за 02 следует 81, следовательно, следующий 1 байт отвечает за длину числа в байтах, если 82 - 2 байта за длину числа. 

Напишем свой декодер для файлов(main.py)

Обратимся к нотации ASN.1 для RSA и увидим передаваемые параметры приватного ключа: 
+ N
+ e
+ d
+ p
+ q
+ dQ
+ dP
+ qInv

Посчитаем количество полей 02. Их оказалось четыре, а так как у нас дан конец приватного ключа, значит у нас есть q. Теперь дело за малым - открыть SAGE и найти флаг.[Ссылка на докер с SAGE](https://github.com/cryptohack/cryptohack-docker)

Поясняю за базовую матешу:

d - секретная экспонента, такая что $$ e * d = 1 \pmod{\phi(N)}$$, значит $$d = e ^{-1} \pmod{\phi(N)}$$, то есть обратный элемент, где  $$\phi(N) = lcm(p - 1, q - 1)$$, где lcm - Наименьший общий делитель

c - зашифрованное сообщение. $$c = m^e \pmod{N}$$, где m - изначальное сообщение

Кольцо - множество всех элементов от 0 до n - 1, где n - составное.

Поле - множество всех элементов от 0 до n - 1, где n - простое.

Поясняю за команды в SAGE:

Zmod - генерация кольца.

Возведя c^d, получаем m.

***FLAG:gigem{Q_Fr0M_Pr1V473_K3Y_89JD54}***


Truncated 2:
=
Условие задачи
-
1. Дан зашифрованный флаг
2. Дан открытый ключ шифрования
3. Дана часть приватного ключа шифрования
 
Решение
-

Распарсив pem'ки, мы выясним, что в приватном ключе всего три параметра
![](img/NO%20q.jpg "NO q? It's unsolveable")

Нерешаемый, то нерешаемый, но для нас он решаемый! 


Разберемся, что за dQ, dP, qInv
-
Криптографы достаточно быстро столкнулись с проблемой увеличения мощностей, что за собой влекло увеличения количества бит в p,q, а как следствие и увеличение d. По итогу увеличевалось время дешифровки.

[Важно Посмотреть!](https://eprint.iacr.org/2020/1506.pdf)
-

Для тех, кто не хочет смотреть pdf:
-
+ $$dQ = d \pmod{q - 1}$$
+ $$dP = d \pmod{p - 1}$$
+ $$qInv = q \pmod{p}$$

В этой пдфке описан процесс дешифровки, а также атака, которой я воспользуюсь.
Так как p > q, по правилам генерации, можно реализовать брутфорс атаку на dP

$$ p = gcd((e * dP - 1) / k + 1 , N)$$ , где $$k \in [1..e]$$  

А дальше делаем все, как в первом решении

***FLAG:gigem{DP_DQ_r54_7rUNC473D_SDA79}***

Эпилог
=

![](img/buh.jpg "За нас, за вас - и за КБ-4 (с)Zer0bp")

Задонатить автору на баночку безалкоголки: https://clck.ru/39wm3q